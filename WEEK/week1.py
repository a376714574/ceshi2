'''

测试开发工程师 主要内容是编写工具 编写脚本 辅做测试功能

能编写自动化脚本算是 不能说是测试开发工程师
测试工程师=开发工程师+测试工程师  有测试经验和开发的能力

日常工作 协助开发编写单元测试 开发测试工具 开发一些测试框架 自动化测试 开发测试平台(比如性能测试的平台让黑盒的人员使用)
        接口自动化

如果不用框架 自己写的话可能你的项目都结束了 你的框架还没写完 所以必须学习框架Django或Flask或者其他的

Django 精装修的房子 大而全 快速使用 非常适用于大型项目
Flask 毛坯房 小巧 灵活 入门简单 非常是用小型网站

python里面一切皆对象
数字 字符串 元祖 字典 列表 方法 类 模块等等都能是对象 连代码都是对象
函数和类都是对象
java里面的不是



class asd:

    def run(self):
        print("as")
        return None

a=asd() #这是一个对象
b=asd   #这是一个类

print(a) #<__main__.asd object at 0x0000000002BC1F60> 这个就是对象
print(b) #<class '__main__.asd'>  class是一个类 可以证明他是一个类 他是一个名为asd的类

#一等
#能不能作为变量来接受  添加数据结构   他是不是可以作为函数的参数传递 能不能作为函数的返回值
#对象符合上面的条件

'''
#
#
# def run(): #函数是否可以作为变量 来传递
#     print("asasd")
#     return None
#
# a=run()#我们在这里调用run()函数 所以他打印的结果是None return返回给调用他的人 这个值"asasd"是函数体内的
#        #所以他会打印出来 因为我们调用的是run()函数
#
# b=run  #他并没有调用run()函数 而是调用的run所以打印出来的是内存地址
#
# print(a) #None
# print(b) #<function run at 0x000000000354CC80>
#
# list=[]
# list.append(a) #他把内容添加进去了 所以函数是可以作为参数 添加到数据结构当中去的
# print(list)
#
# def use_run(asd):
#     a=asd         #可以作为参数传递
#     return a     #可以作为返回值
#
# print(use_run(run)) #run不加括号就是把run函数传递 如果加了()调用函数 所以会执行函数里面的内容也会 输出返回值
#
# #对象特征
# #身份 id
# # #类型 人类
# # #值   a=1
# #
# # # 判断是否是一个对象 就用id 类型就是
# # #什么是变量 变量是存储数据的 变量是一种对象的引用
# # #java不同的类型盒子大小不一样
# # #a=1 首先他会建立一个内存把1放进去  在另一个地方建立一个类似指针的东西
#                                  #虽然建立了指针 但是如何和和1做出连接
#                                   #可以打开这个指针 里面会有一个类似纸条子一样的东西
#                                   #里面会有一个指向1的内存地址0x01类似这种感觉内存地址
#
# a=1
# b=a                #a=1 在内存里面开辟了一块区域放入1 b=a就是把放入1的那个内存地址给b所以只是把链接给他了
#                      #并不是创造了一个新的对象
# # print(id(a))
# # print(id(b))
# #
# aaa=1
# print(aaa)  #他们不是一个对象
# aaa=2       #这部操作会让aaa再次创造一个新的内存地址
# print(aaa)
#
# aaaaa=1
# bbbbb=a+"1"
# print(aaaaa) #他们不是一个内存地址 "1"这样也算是创建一个新的对象 所以旧的加上新的会变成另一个对象
# print(bbbbb)
#
#
# sss=[1,2]
# ccc=sss
# print(ccc)
# sss.append(3)  #这种添加方法并没有创建一个新的对象 所以他们是一个内存地址
# print(id(sss))
# print(id(ccc))
# # print(sss is ccc) #is判断他们是否是一个对象
# #
# # print([1,2]+[3])
#
# a=1 # 1 是int类的一个对象 也可以说是一个实例类似于a=asd()这种感觉
# c=type(int)
# print(c) # <class 'type'> int是type的一个对象  所有类型都一样 所有类型都是一个type的对象 类就是一个对象
#           #每一个对象都是由类初始化出来的                                        #type类的对象
# #深入理解type object class就能明白一切皆对象
#
# print(type(type))# 检查一下type这个类的类型 <class 'type'> 结果还是type所以它既是对象又是类

# 垃圾回收-------------------------------
#  #会在内存开创一个区域 如果变量过多 内存不足新的对象就无法再次创建了 会导致内存溢出就是满了
#     #所以对象不会是一直在内存中的
#     #
# a=1
# b=a  #这个时候1就有了两个标签a和b  引用计数实际上就是数标签有几个
#      #这个时候内存会开辟一块区域存入1 但是他还有两个标签a和b所以他会持续占领内存f
# a=3  #这个时候1的标签只剩下了b 但是他还是存在内存当中的 因为他还有引用标签
#
# b=a
# #或者    这个时候b的标签指针也被替换到了新的地方 上面的1没有了引用标签内存就会把他清理掉
# b=1
#
# a=[1,2,3]
# b=[3,2,1]
# #循环利用 永远不会被内存清理
# [1, 2, 3, [3, 2, 1, [...]]]
# [3, 2, 1, [1, 2, 3, [...]]]

#面试前要详细了解 类属性 实例属性
#实例方法 静态方法 类方法 他们的区别和用到的场景
#函数 闭包 装饰器 三元表达式 深浅拷贝 多线程 高并发 GIL
#去了解分代回收

# class是一个类 object是一个对象
#
# class asd:
#
#
#     def __init__(self,a):
#         b=1111
#
#         self.a=a  #self.a是一个实例属性
#         self.b=[]
#
# # asd('asad').a="1"         #这一步骤实例化了属性然后赋值
# # print(asd("asad").a)   #这里面又重新实例化了属性然后打印 所以这个是新的对象和上面没有关系 上面的那个 1
# # print(asd("dsad").b)      # 是一个内存地址里面的值 我下面实例化有创造出来了一个内存地址 虽然上面有修改
# #                                #但也仅仅局限于他的那个内存里面的变动 影响不到我 两个内存地址的打印所以没有关系
# # asd('asad').a="1"  #类似于a=1
# # print(asd("asad").a) #然后a=2一样的感觉
#
# aa=asd("1")
# aa.b=[11]
# print(aa.__dict__) #{'b': [11], 'a': '1'}他会把自己的实例属性打印出来 实例属性b被赋值了而且用的是同一对象
# # 所以成功了
#
# print(asd.__dict__)

#了解一下新世类

class a:
    # asd="a"
    print()

class b():
    asd="b"

class c(a):
    pass


class asddd(c,b): #关于深度优先和广度优先 python采用了一种c3算法 如果两个类都继承a那么就采用广度优先
                    #广度运算就是运行完c后发现没有结果但是并没有顺着c的继承轨迹去找a而是去按照广度去找了b
                    #如果b在没有才会按照原来的轨迹去找a

                    #如果c继承了a  b没有继承a 现在的继承c b这种方式会先运行c发现c没有 会按照继承轨迹去找a
                    #优先深度如果a在没有才回去找b
    def __init__(self):
        #实例属性
        self.a=a
        pass

#上面的问题叫做菱形问题 什么时候是广度优先 什么时候是深度优先 c3算法为什么要创建


